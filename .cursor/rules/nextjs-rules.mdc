---
description: ACEDD NGO website & admin panel â€“ Next.js 15 / React 19 / TypeScript 5 / Tailwind 4 / Prisma + MariaDB
alwaysApply: true
globs:
  - "src/**/*.{ts,tsx}"
---

# ACEDD â€“ Project Rules for Cursor

You are working inside the **ACEDD NGO** full-stack Next.js project.

Your goals:

1. **Preserve** the existing architecture, routes, and domain language (Turkish field names, statuses, etc.).
2. **Extend** the admin panel and public site in a consistent, maintainable way.
3. **Guide** the gradual migration from **MongoDB** to **Prisma + MariaDB** without breaking existing features.

---

## 1. Project scope & architecture

- Framework: **Next.js 15 App Router** (`src/app`).
- Language: **TypeScript** with `strict` mode.
- UI: **React 19** function components + hooks.
- Styling: **Tailwind CSS v4** â€“ prefer class utilities over inline styles.
- Database:
  - Legacy: `src/lib/mongodb.ts` + MongoDB collections.
  - Primary (new): **Prisma + MariaDB** (`prisma/schema.prisma`, `src/lib/db.ts`).
- App segments:
  - Public site: `src/app/(pages)/**`
  - Admin panel: `src/app/(admin)/admin/**`
  - API routes: `src/app/api/**`
  - Shared logic: `src/contexts/**`, `src/lib/**`, `src/components/**`

Always keep a **clear separation** between:

- UI components
- Data-fetching / API layer
- Database access (Prisma or legacy Mongo)

---

## 2. Folder structure conventions

Follow and extend the existing structure:

- **Public pages** (`src/app/(pages)`):
  - Route folders:  
    - `/` (home), `/etkinlikler`, `/hakkimizda`, `/burs-basvuru`, `/uyelik-basvuru`, `/bagis-yap`, `/iletisim`, etc.
  - Inside each route:
    - `page.tsx` â€“ main page component.
    - `constants.ts` â€“ domain types and static content.
    - `components/` â€“ page-specific UI pieces.

- **Admin panel** (`src/app/(admin)/admin`):
  - `layout.tsx` â€“ admin layout wrapper.
  - `components/AdminLayout.tsx` â€“ sidebar, header, main content.
  - Feature folders:
    - `admin/page.tsx` â€“ Dashboard
    - `admin/burs-basvurulari/page.tsx`
    - `admin/uyeler/page.tsx`
    - `admin/etkinlikler/page.tsx`
    - `admin/duyurular/page.tsx`
    - `admin/ayarlar/page.tsx`
  - Reusable admin UI belongs in `admin/components/`.

- **API routes** (`src/app/api`):
  - `members`, `membership-applications`, `board-members`, `events`, `datasets`, `upload`, etc.
  - A debug route for Prisma: `api/debug/prisma-test/route.ts`.

- **Shared modules**:
  - `src/contexts/*` â€“ React Contexts (Members, Events, future Announcements).
  - `src/lib/types/*` â€“ domain types (Member, MembershipApplication, BoardMember, Event, Announcement, etc.).
  - `src/lib/constants/*` â€“ global constants and configuration.
  - `src/lib/hooks/*` â€“ shared hooks.
  - `src/lib/utils/*` â€“ helpers (e.g. `cn`).
  - `src/lib/db.ts` â€“ Prisma client (MariaDB).
  - `src/lib/mongodb.ts` â€“ legacy Mongo driver (do not extend).

- **Component organization** â€“ **CRITICAL: Follow this structure strictly**

  **1. Shared/Reusable Components** (`src/components/`):
  
  - `src/components/ui/` â€“ **UI primitives** (generic, reusable building blocks)
    - Examples: `Button`, `Input`, `Card`, `Select`, `Textarea`, `Badge`, `FileUpload`
    - These have NO domain logic, NO business rules
    - Can be used anywhere in the app (public pages, admin panel, etc.)
  
  - `src/components/layout/` â€“ **Layout components** (site-wide structure)
    - Examples: `Header`, `Footer`, `ConditionalLayout`
    - These define the overall page structure
    - Used across multiple routes/pages

  **2. Page-Specific Components** (`src/app/(pages)/<route>/components/`):
  
  - **Public page components** â€“ Components used ONLY in a specific public page
    - Examples:
      - `src/app/(pages)/home/components/HeroSection.tsx` (only on homepage)
      - `src/app/(pages)/home/components/AnnouncementStrip.tsx` (only on homepage)
      - `src/app/(pages)/home/components/AnnouncementStripSection.tsx` (only on homepage)
      - `src/app/(pages)/etkinlikler/components/EventsGrid.tsx` (only on events page)
    - **Rule:** Even if a component is domain-specific (e.g., announcement-related), if it's ONLY used in one page, it belongs in that page's `components/` folder
  
  - Each route folder structure:
    ```
    src/app/(pages)/<route>/
      â”œâ”€â”€ page.tsx
      â”œâ”€â”€ constants.ts
      â”œâ”€â”€ components/
      â”‚   â”œâ”€â”€ ComponentName.tsx
      â”‚   â””â”€â”€ index.ts
      â””â”€â”€ hooks/ (optional)
    ```

  **3. Admin-Specific Components** (`src/app/(admin)/admin/components/`):
  
  - **Admin panel components** â€“ Components used ONLY in admin panel
    - Examples:
      - `AdminLayout.tsx` (admin layout wrapper)
      - `AdminAnnouncementsTable.tsx` (admin announcements management)
      - `AnnouncementFormDialog.tsx` (admin announcement form)
      - `AnnouncementsSummaryWidget.tsx` (admin dashboard widget)
    - **Rule:** All admin-specific components stay in `admin/components/`, even if they're domain-specific

**Component placement decision tree:**

1. **Is it a generic UI primitive?** (button, input, card, select, etc.)
   â†’ `src/components/ui/`
   - âœ… No domain logic
   - âœ… Reusable across entire app

2. **Is it a layout component?** (header, footer, sidebar, conditional layout)
   â†’ `src/components/layout/`
   - âœ… Site-wide structure
   - âœ… Used across multiple routes

3. **Is it admin-specific?** (only used in admin panel)
   â†’ `src/app/(admin)/admin/components/`
   - âœ… Admin dashboard widgets
   - âœ… Admin management tables/forms
   - âœ… Admin-specific layouts

4. **Is it page-specific?** (used in only ONE public page/route)
   â†’ `src/app/(pages)/<route>/components/`
   - âœ… Home page components â†’ `home/components/`
   - âœ… Events page components â†’ `etkinlikler/components/`
   - âœ… Contact page components â†’ `iletisim/components/`
   - **Important:** Even domain-specific components (announcements, events, etc.) go here if they're only used in one page

5. **Is it shared across MULTIPLE pages?** (used in 2+ different routes)
   â†’ `src/components/<domain>/`
   - âš ï¸ **Rare case** â€“ Only use this if a component is truly shared across multiple pages
   - Example: Future `EventCard` used in both events list page AND homepage
   - **Default:** Prefer page-specific placement unless truly needed in multiple places

**Examples:**

- âœ… `src/components/ui/Button.tsx` â€“ Generic UI primitive
- âœ… `src/components/layout/Header.tsx` â€“ Site-wide layout
- âœ… `src/app/(pages)/home/components/AnnouncementStrip.tsx` â€“ Home page only
- âœ… `src/app/(pages)/home/components/AnnouncementStripSection.tsx` â€“ Home page only
- âœ… `src/app/(admin)/admin/components/AnnouncementFormDialog.tsx` â€“ Admin only
- âŒ `src/components/announcements/` â€“ Don't create unless truly shared across multiple pages

When you add new functionality:

- **Domain types** â†’ `src/lib/types/<domain>.ts`
- **API endpoints** â†’ `src/app/api/<domain>/**`
- **Admin pages** â†’ `src/app/(admin)/admin/<domain>/page.tsx`
- **Public UI components** â†’ Follow the decision tree above

---

## 3. Coding standards & quality gates

### 3.1. TypeScript & style

- `strict` mode must remain enabled.
- Avoid `any`. If truly necessary:
  - Limit scope,
  - Add a comment explaining why.
- Prefer `type`/`interface` for domain models over ad-hoc inline types.
- Use **ESLint + Prettier** conventions (no custom style unless required by the repo).

### 3.2. Commits & PRs (mental model for changes)

Assume the following workflow and keep diffs compatible with it:

- **Trunk-based development**, feature branches are short-lived.
- Commit messages follow **Conventional Commits**:
  - `feat:`, `fix:`, `refactor:`, `test:`, `chore:`, etc.
- Each PR should be:
  - **< 300 LOC** of meaningful change when possible.
  - Focused on a single feature or refactor.
- Include tests and docs updates in the same PR when you change behavior.

### 3.3. Testing expectations

- New non-trivial business logic (validation, status transitions, filtering, etc.) should live in small pure functions under `src/lib/**` and be unit-testable.
- Aim for:
  - â‰¥ 80% coverage overall,
  - â‰¥ 90% on critical modules (auth, payments/donations, admin actions).
- When you add new APIs:
  - Cover success, validation error, and generic failure paths.

### 3.4. CI/CD expectations

Design code changes as if CI runs the following pipelines:

1. Install & build
2. TypeScript check
3. ESLint
4. Tests + coverage threshold enforcement
5. Prisma migrations (if schema changed)
6. Dependency audit (no high-severity vulns)

Code you write should be ready to pass all of the above.

### 3.5. Security & secrets

- Never hardcode secrets, tokens, or connection strings.
- Use environment variables (e.g. `DATABASE_URL`) loaded outside the repo.
- When logging errors:
  - Log enough to debug,
  - Do **not** log sensitive data (passwords, personal details, etc.).
- For admin features:
  - Assume they must be protected by authentication (even if not fully implemented yet).
  - Do not rely on â€œhidden URLsâ€ as security.

---

## 4. Data layer rules (MongoDB â†’ Prisma migration)

The project is in a **gradual migration** from MongoDB to Prisma + MariaDB.

### 4.1. Legacy MongoDB (keep stable)

- `src/lib/mongodb.ts` â€“ legacy client and collection helpers.
- Existing APIs under `src/app/api/**` that import from `lib/mongodb` must continue to work until fully migrated.
- **Do not**:
  - Add new collections or new logic to Mongo.
  - Introduce new features that depend on Mongo.

If you must touch Mongo-based routes:

- Either keep behavior **as-is**, or
- Plan a full migration for that feature:
  1. Add/adjust Prisma models.
  2. Write Prisma-backed API routes.
  3. Update contexts/hooks to call the new API.
  4. Ensure UI behavior stays the same.

### 4.2. Prisma + MariaDB (source of truth for new work)

- `prisma/schema.prisma` defines models such as:
  - `AdminUser` + `AdminRole` enum
  - `Announcement`
  - `Member`
  - `MembershipApplication`
  - `BoardMember`
  - `Event`
  - and potential CMS models (`Page`, `ContentBlock`, etc.).
- `src/lib/db.ts` must be the **only place** where `PrismaClient` is instantiated.
  - Use the MariaDB adapter.
  - Use the global singleton pattern for dev.

**Rules for new features:**

1. **All new persistent data must use Prisma.**
2. Frontend types for domain entities should mirror Prisma models:
   - Use explicit DTOs if you donâ€™t want to expose all fields.
3. UI components must not import `prisma` directly.
   - Use API routes (`src/app/api/**`) or server actions instead.

**âš ï¸ Critical: Schema Change Workflow**

When adding new models or fields, **always follow this order:**

1. **First:** Update `prisma/schema.prisma` with your changes
   - Add/modify models, fields, indexes, enums, etc.
   - `schema.prisma` is the **single source of truth**

2. **Second:** Create and apply migration (local only):
   ```bash
   npx prisma migrate dev --name descriptive_name
   ```
   This creates migration files and applies them to local DB.

3. **Third:** Update TypeScript types and API handlers
   - Prisma Client is auto-regenerated after migration
   - Update `src/lib/types/*` if needed
   - Update API routes to use new schema

4. **Fourth:** Commit migration files
   - Always commit `prisma/migrations/` folder
   - Production will use these migration files

**Never:**
- âŒ Modify database directly without updating `schema.prisma` first
- âŒ Skip migration files (they are required for production)

**Note:** `prisma db push` erken aÅŸamada hÄ±zlÄ± iterasyon iÃ§in kabul edilebilir, ancak production-ready deÄŸiÅŸiklikler iÃ§in `prisma migrate dev` kullan.

### 4.2.1. Prisma Migration Strategy

**Åu Anki Durum (Sprint 0):**
- Tek DB kullanÄ±lÄ±yor (geliÅŸtirme ve ilk yayÄ±n iÃ§in)
- Bu DB dev gibi davranÄ±yor: `prisma migrate dev` kullanÄ±labilir
- Shadow DB: `.env`'de tanÄ±mlamaya gerek yok, Prisma otomatik oluÅŸturmaya Ã§alÄ±ÅŸÄ±r
- `prisma db push` erken aÅŸamada hÄ±zlÄ± iterasyon iÃ§in kabul edilebilir

**Ä°lk Prod Release SonrasÄ±:**
- Åu anki DB prod sayÄ±lacak
- AyrÄ± dev DB aÃ§Ä±lacak
- Dev DB'de `prisma migrate dev`, prod DB'de `prisma migrate deploy` kullanÄ±lacak

**Critical rules for database migrations (Ä°lk Prod Release SonrasÄ±):**

#### ğŸ”¹ Kural 1 â€“ Production (Plesk) Ã¼zerinde asla `prisma migrate dev` Ã§alÄ±ÅŸtÄ±rma

**âš ï¸ CRITICAL: Production'da ASLA `prisma migrate dev` kullanma!**

- **Production/Plesk'te sadece:**
  ```bash
  npx prisma migrate deploy
  ```
- Migration dosyalarÄ± zaten lokalinde Ã¼retilmiÅŸ ve test edilmiÅŸ olacak.
- `prisma migrate dev` shadow database gerektirir ve production DB kullanÄ±cÄ±sÄ±nÄ±n yeni DB oluÅŸturma yetkisi olmayabilir.
- `prisma migrate dev` yeni migration dosyasÄ± oluÅŸturur (production'da istenmez).
- Production'da sadece mevcut migration dosyalarÄ±nÄ± uygulamak iÃ§in `prisma migrate deploy` kullan.

**Production migration checklist:**
- [ ] Migration dosyalarÄ± local'de oluÅŸturuldu ve test edildi
- [ ] Migration dosyalarÄ± commit edildi
- [ ] Kod Plesk'e deploy edildi
- [ ] Plesk'te `npx prisma migrate deploy` Ã§alÄ±ÅŸtÄ±rÄ±ldÄ± (ASLA `migrate dev` deÄŸil!)

#### ğŸ”¹ Kural 2 â€“ Shadow DB (Otomatik)

**Åu Anki Strateji (Sprint 0 - Prod Release Ã–ncesi):**
- Tek DB kullanÄ±lÄ±yor (geliÅŸtirme ve ilk yayÄ±n iÃ§in)
- Schema deÄŸiÅŸiklikleri iÃ§in `prisma db push` kullanÄ±lÄ±r
  - âœ… Tablo/kolonlar direkt DB'de gÃ¼ncellenir
  - âœ… Shadow DB'ye ihtiyaÃ§ duymaz
  - âŒ Migration dosyasÄ± Ã¼retilmez (ÅŸimdilik sorun deÄŸil)
- Test iÃ§in: `npx prisma studio` ile tablolarÄ± kontrol edebilirsiniz

**Ä°lk Prod Release SonrasÄ±:**
- Åu anki DB prod sayÄ±lacak
- AyrÄ± dev DB aÃ§Ä±lacak
- Dev DB'de `prisma migrate dev`, prod DB'de `prisma migrate deploy` kullanÄ±lacak

#### ğŸ”¹ Kural 3 â€“ `prisma db push` (Åu Anki Strateji - Prod Release Ã–ncesi)

**Åu Anki Durum (Sprint 0):**
- `prisma db push` kullanÄ±lÄ±r (migration dosyasÄ± Ã¼retilmez)
- Shadow DB'ye ihtiyaÃ§ duymaz
- Schema deÄŸiÅŸiklikleri direkt DB'ye uygulanÄ±r
- Test iÃ§in: `npx prisma studio` ile tablolarÄ± kontrol edebilirsiniz

**Prod Release SonrasÄ±:**
- `prisma db push` artÄ±k kullanÄ±lmayacak
- Dev DB'de `prisma migrate dev` + migration dosyalarÄ± kullanÄ±lacak
- Prod DB'de `prisma migrate deploy` kullanÄ±lacak
- `db push` migration geÃ§miÅŸi oluÅŸturmaz, prod release sonrasÄ± kabul edilemez

**Workflow Ã¶zeti (Åu An):**
1. Schema deÄŸiÅŸikliÄŸi: `prisma/schema.prisma` gÃ¼ncelle
2. DB'ye uygula: `prisma db push`
3. Test: `prisma studio` veya test route

**Workflow Ã¶zeti (Prod Release SonrasÄ±):**
1. Dev DB'de: `prisma migrate dev` (shadow DB ile)
2. Migration dosyalarÄ±nÄ± commit et
3. Production deploy: `prisma migrate deploy` (shadow DB gerekmez)

### 4.3. Announcements (Duyurular) as the first fully Prisma feature

**Prisma model (already exists conceptually):**

- `Announcement`:
  - `id` (uuid),
  - `title`, `summary`, `content`,
  - `category` (string; may later become enum),
  - `startsAt`, `endsAt`,
  - `isPinned` (boolean),
  - `createdAt`, `updatedAt`,
  - indexes on `category`, `isPinned`, `startsAt`.

**TypeScript type:**

Create `src/lib/types/announcement.ts`:

```ts
export type AnnouncementCategory =
  | "general"
  | "scholarship"
  | "event"
  | "system"
  | string; // allow future/custom categories

export interface Announcement {
  id: string;
  title: string;
  summary?: string;
  content: string;
  category: AnnouncementCategory;
  startsAt?: string; // ISO 8601
  endsAt?: string;   // ISO 8601
  isPinned: boolean;
  createdAt: string;
  updatedAt: string;
}
